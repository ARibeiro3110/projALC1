\documentclass[12pt,a4paper]{article}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{pdflscape}
\usepackage{svg}
\usepackage{hyperref}
\usepackage{enumitem}

\newcommand{\reporttitle}{Projeto 1 -- Flying Tourist Problem}
\newcommand{\authorname}{Afonso da Conceição Ribeiro}
\newcommand{\authorgroup}{20}
\newcommand{\authorid}{ist1102763}
\newcommand{\reportauthor}{\textbf{\authorname} (\authorid) -- Grupo \textbf{\authorgroup}}
\newcommand{\reportsubject}{Algoritmos para Lógica Computacional}
\newcommand{\reportyear}{2024/2025}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    citecolor=blue,
    pdftitle={\reporttitle},
    pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\lhead{\reporttitle}
\rhead{\reportsubject}
\lfoot{\reportauthor}
\rfoot{\thepage}


\renewcommand{\footrulewidth}{0.2pt}

\renewcommand\thesection{\arabic{section}.}
\renewcommand\thesubsection{\thesection\arabic{subsection}.}
\renewcommand\thesubsubsection{\thesubsection\arabic{subsubsection}.}

\begin{document}
    \begin{titlepage}
        \centering
        \vspace*{5cm}
        {\Huge \textbf{\reporttitle} \par}

        \vspace{0.5cm}
        {\LARGE \reportsubject \par}

        \vspace{0.5cm}
        {\large \reportyear \par}

        \vspace{2cm}
        {\large \reportauthor \par}
        
        \vfill
        \renewcommand{\contentsname}{Índice}
        \tableofcontents

        \thispagestyle{empty}
        \clearpage
        
    \end{titlepage}


    \setcounter{page}{2}
    \setlength{\parskip}{0em}


    \section{Problema a resolver}
        O Flying Tourist Problem é um problema de otimização em que um turista precisa de planear uma viagem por várias cidades, minimizando o custo dos bilhetes de avião. Este inicia e termina a viagem na mesma cidade, e passa em cada cidade um número fixo de noites. A ordem das cidades a visitar não é predefinida, e o turista é obrigado a utilizar apenas voos diretos. O problema é modelado como um problema de otimização de Maximum Satisfiability (MaxSAT) e resolvido utilizando solvers correspondentes.

    \section{Como instalar e correr o projeto}
        \begin{itemize}
            \item Clonar o repositório do GitLab.
            \item Navegar até à diretoria do projeto.
            \item Correr o projeto utilizando o seguinte comando: \\
                  \texttt{python3 project1.py < input.ttp > output.myout}
            \item Comparar o conteúdo do ficheiro de output obtido com o output esperado.
        \end{itemize}

    \section{Codificação do problema}
        A partir de um ficheiro de input que represente uma instância do problema, obtêm-se as seguintes variáveis e conjuntos:
        \begin{itemize}
            \item $\mathcal{C}$: conjunto das cidades que o turista pretende visitar e a cidade de origem
            \item $n = \lvert \mathcal{C} \rvert$: número total de cidades
            \item $base$: a cidade de origem, $base \in \mathcal{C}$
            \item $k_c$: número de noites que o turista pretende passar na cidade $c$,
                  $\forall c \in \mathcal{C} \setminus \{base\}$
            \item $\mathcal{F}$: conjunto dos voos em consideração
            \item $m = \lvert \mathcal{F} \rvert$: número total de voos
            \item $d_f$: data do voo $f$, $\forall f \in \mathcal{F}$
            \item $w_f$: custo do voo $f$, $\forall f \in \mathcal{F}$
        \end{itemize}
        E definem-se as seguintes:
        \begin{itemize}
            \item $x_i = 1$ se e só se o voo $f_i$ é escolhido
            \item $K = \sum_{i = 1, c_i \neq base}^{n}{k_{c_i}}$
            \item $\mathcal{O}_c \subset \mathcal{F}$: conjunto dos voos com origem na cidade $c$, $\forall c \in \mathcal{C}$
            \item $\mathcal{D}_c \subset \mathcal{F}$: conjunto dos voos com destino à cidade $c$, $\forall c \in \mathcal{C}$
        \end{itemize}
        Os conjutos de cláusulas utilizadas na codificação do problema são descritos nas subsecções seguintes.

    \subsection{Soft clauses}
        O conjunto das soft clauses, $\varphi_S$, contém as negações das escolhas de cada um dos voos, com peso associado $w_{f_i}$, para minimizar o custo da viagem.
        \begin{equation}
            \varphi_S = \bigwedge_{i = 1}^m \neg x_i
            \label{soft_clauses}
        \end{equation}

    \subsection{Hard clauses}
        O conjunto das hard clauses, $\varphi_H$, é definido da seguinte forma, sendo os conjuntos $\varphi_1$, $\varphi_2$, $\varphi_3$ e $\varphi_4$ definidos a seguir.
        \begin{equation}
            \varphi_H = \varphi_1 \land \varphi_2 \land \varphi_3 \land \varphi_4
            \label{hard_clauses}
        \end{equation}
        Os primeiros dois conjuntos de hard clauses, $\varphi_1$ e $\varphi_2$, garantem que, para cada cidade, há exatamente um voo escolhido com, respetivamente, destino e origem na mesma.
        \begin{equation}
            \varphi_1 =
            \bigwedge_{c \in \mathcal{C}}
            \left(
            \sum_{\substack{i = 1 \\
                            f_i \in \mathcal{D}_c}}
                ^{m}
                {x_i} = 1
            \right)
            \label{destination_c}
        \end{equation}
        \begin{equation}
            \varphi_2 =
            \bigwedge_{c \in \mathcal{C}}
            \left(
            \sum_{\substack{i = 1 \\
                            f_i \in \mathcal{O}_c}}
                ^{m}
                {x_i} = 1
            \right)
            \label{origin_c}
        \end{equation}
        De seguida, o conjunto de hard clauses $\varphi_3$ assegura que, para cada cidade visitada, se um certo voo com destino nessa cidade é escolhido, então o voo com origem nessa cidade escolhido acontece $k_c$ dias depois (note-se que $x \Rightarrow y \equiv \neg x \lor y$).
        \begin{equation}
            \varphi_3 =
            \bigwedge_{c \in \mathcal{C} \setminus \{base\}}
            \left(
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{D}_c}}
                     ^{m}
            \left(
            \neg x_i \lor
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{O}_c \\
                               d_{f_j} = d_{f_i} + k_c}}
                ^{m}
                {x_j}
            \right)
            \right)
            \label{k_nights}
        \end{equation}
        No caso da cidade $base$, é o voo com destino na cidade que tem de acontecer depois do voo com origem, mais especificamente $K$ dias depois, o que é cumprido pelo conjunto de hard clauses $\varphi_4$.
        \begin{equation}
            \varphi_4 =
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{O}_{base}}}
                     ^{m}
            \left(
            \neg x_i \lor
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{D}_{base} \\
                               d_{f_j} = d_{f_i} + K}}
                ^{m}
                {x_j}
            \right)
            \label{K_nights_base}
        \end{equation}
        
        \vspace{\baselineskip}
        \vspace{\baselineskip}
        \vspace{\baselineskip}
        \noindent Desta forma, fica definida a fórmula MaxSAT que codifica o problema: $\varphi = \varphi_S \land \varphi_H$.
            
    \section{Algoritmo e configurações usadas}
        A fórmula MaxSAT que codifica o problema é uma instância da classe \texttt{WCNF}, da biblioteca \texttt{PySAT}, que permite manipular fórmulas CNF com soft clauses e hard clauses, e é construída utilizando os métodos \texttt{append} ou \texttt{extend} para adicionar uma cláusula ou um conjunto de cláusulas, respetivamente.
        
        O algoritmo utilizado é o \texttt{RC2}, da biblioteca \texttt{PySAT}, cuja instância é criada recebendo no seu construtor a fórmula \texttt{WCNF}. O seu método \texttt{compute} calcula a solução ótima e devolve uma lista das variáveis que constam na fórmula, positivas caso lhes tenha sido atribuído o valor \texttt{True} e negativas caso contrário. Para tal, o \texttt{RC2} pode usar qualquer SAT solver disponível no \texttt{PySAT}, usando, neste caso, por defeito, o \texttt{g3}.
        
        De seguida, encontram-se as variáveis positivas da solução, que correspondem aos voos escolhidos, e calcula-se a soma dos custos desses voos. Finalmente, imprimem-se o valor total e os voos escolhidos para o \texttt{stdout}, no formato requerido.


    \subsection{Formulação das cláusulas}
        A formulação das cláusulas correspondentes às fórmulas lógicas \ref{soft_clauses}, \ref{k_nights} e \ref{K_nights_base} é direta, pois estas apenas utilizam os conectores lógicos $\land$ e $\lor$, sendo que, em Python, as disjunções são representadas através de listas de variáveis, enquanto as conjunções são tratadas ao adicionar múltiplas cláusulas à fórmula.

        Já a formulação das cláusulas correspondentes às fórmulas \ref{destination_c} e \ref{origin_c} utiliza restrições Equals1, pelo que se utiliza o método \texttt{equals} da classe \texttt{CardEnc} da biblioteca \texttt{PySAT}, o qual devolve um conjunto de cláusulas CNF construídas a partir de um tipo de codificação especificado, neste caso, pairwise.

    \subsubsection{Tipo de codificação pairwise}
        A codificação de restrições Equals1 é feita a partir da conjunção das restrições AtMost1 e AtLeast1:
        \begin{equation}
            \sum_{i=1}^{n} x_i = 1 \quad \equiv \quad \left( \sum_{i=1}^{n} x_i \leq 1 \right) \land \left( \sum_{i=1}^{n} x_i \geq 1 \right)
        \end{equation}
        A restrição AtLeast1 assegura que pelo menos uma das variáveis tem atribuído o valor \texttt{True}, o que se obtém a partir da disjunção de todas:
        \begin{equation}
            \sum_{i=1}^{n} x_i \geq 1 \quad \equiv \quad \left( x_1 \lor \dots \lor x_n \right)
        \end{equation}
        A restrição AtMost1, utilizando a codificação pairwise, garante que, no máximo, uma das variáveis seja atribuída como \texttt{True}. Esta codificação cria $^nC_2$ cláusulas, uma para cada par de variáveis distintas, sendo que o significado de cada cláusula é que, para um par de variáveis, pelo menos uma delas deve ser falsa. Se fossem atribuídos valores \texttt{True} a duas variáveis diferentes, haveria uma cláusula contendo ambas como verdadeiras, o que violaria a restrição. Portanto, a codificação pairwise garante que apenas uma variável será verdadeira.
        \begin{equation}
            \sum_{i=1}^{n} x_i \leq 1 \quad \equiv \quad \bigwedge_{1 \leq i < j \leq n} \left( \neg x_i \lor \neg x_j \right)
        \end{equation}


    \section{Variantes deste problema}

    \subsection{Com escalas diurnas ao viajar entre cidades}
        A partir do ficheiro de input, obtêm-se agora, também, as horas de partida e de chegada dos voos, não necessárias anteriormente:
        \begin{itemize}
            \item $h_{f}^{d}$: hora de partida do voo $f$, $\forall f \in \mathcal{F}$
            \item $h_{f}^{a}$: hora de chegada do voo $f$, $\forall f \in \mathcal{F}$
        \end{itemize}
        Definem-se as seguintes variáveis e conjuntos:
        \begin{itemize}
            \item $\omega \subset \mathcal{F}$: um itinerário é uma lista ordenada de voos, tal que:
                \begin{itemize}
                    \item $\lvert \omega \rvert = \lambda$ ; \quad se $\lambda = 1$, $\omega$ é apenas um voo
                    \item $\omega_i$ é o $i$-ésimo voo de $\omega$
                    \item $\forall i \in \{1, \dots, \lambda-1\}: \quad \omega_i \in \mathcal{D}_c \Rightarrow \omega_{i+1} \in \mathcal{O}_c \quad , \quad d_{\omega_i} = d_{\omega_{i+1}} \quad , \quad h_{\omega_i}^{a} \leq h_{\omega_{i+1}}^{d}$
                    \item $\omega \in \mathcal{O}_c \Leftrightarrow \omega_1 \in \mathcal{O}_c$
                    \item $\omega \in \mathcal{D}_c \Leftrightarrow \omega_{\lambda} \in \mathcal{D}_c$
                \end{itemize}
            \item $\mathcal{I} \subset \mathcal{P}(\mathcal{F})$: conjunto dos itinerários em consideração
        \end{itemize}
        E alteram-se as definições das seguintes variáveis e conjuntos já usados:
        \begin{itemize}
            \item $d_\omega$: data do itinerário $\omega$
            \item $w_\omega = \sum_{i = 1}^{\lambda}{w_{\omega_i}}$: custo do itinerário $\omega$
            \item $x_i = 1$ se e só se o itinerário $\omega_i$ é escolhido
            \item $\mathcal{O}_c \subset \mathcal{I}$: conjunto dos itinerários com origem na cidade $c$, $\forall c \in \mathcal{C}$
            \item $\mathcal{D}_c \subset \mathcal{I}$: conjunto dos itinerários com destino à cidade $c$, $\forall c \in \mathcal{C}$
        \end{itemize}
        Dadas estas mudanças, os conjuntos de cláusulas utilizadas na codificação do problema mantêm-se, passando-se a usar o conceito de itinerário no lugar do conceito de voo. Um itinerário consiste numa viagem entre duas cidades utilizando um ou mais voos, todos no mesmo dia (ou seja, com possíveis escalas diurnas). Generalizando o conceito de voo para itinerário com cardinalidade 1, obtém-se uma solução correspondente a um conjunto de itinerários, que por sua vez permite chegar ao conjunto de voos escolhidos.

    \newpage

    \subsection{Com um número de noites flexível entre cidades}
        A partir do ficheiro de input, obtêm-se agora, em vez de $k_c$, os números mínimos e máximos de noites em cada cidade:
        \begin{itemize}
            \item $k_c^-$: número mínimo de noites a passar na cidade $c$, $\forall c \in \mathcal{C} \setminus \{base\}$
            \item $k_c^+$: número máximo de noites a passar na cidade $c$, $\forall c \in \mathcal{C} \setminus \{base\}$
        \end{itemize}
        E definem-se as seguintes variáveis:
        \begin{itemize}
            \item $K^- = \sum_{i = 1}^{n}{k_{c_i}^-}$
            \item $K^+ = \sum_{i = 1}^{n}{k_{c_i}^+}$
        \end{itemize}
        É necessário proceder a alterações nas fórmulas lógicas \ref{k_nights} e \ref{K_nights_base}:
        \begin{equation}
            \varphi_3 =
            \bigwedge_{c \in \mathcal{C} \setminus \{base\}}
            \left(
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{D}_c}}
                     ^{m}
            \left(
            \neg x_i \lor
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{O}_c \\
                               k_c^- \leq d_{f_j} - d_{f_i} \leq k_c^+}}
                ^{m}
                {x_j}
            \right)
            \right)
            \label{k_nights_var}
        \end{equation}
        \begin{equation}
            \varphi_4 =
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{O}_{base}}}
                     ^{m}
            \left(
            \neg x_i \lor
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{D}_{base} \\
                               K^- \leq d_{f_j} - d_{f_i} \leq K^+}}
                ^{m}
                {x_j}
            \right)
            \label{K_nights_base_var}
        \end{equation}
        Note-se que estas restrições na escolha de voos garantem que se continua a ter, para os números efetivos de noites a passar fora de $base$ e em cada cidade, $K = \sum_{i = 1, c_i \neq base}^{n}{k_{c_i}}$.

\end{document}